import { describe, test, expect, beforeEach, afterEach } from "bun:test";
import path from "path";
import fs from "fs/promises"; // Use promises for async/await
import { ObsidianServer } from "../src/server"; // Adjust path as needed

// Import necessary tools (add more as needed)
import { createCreateNoteTool } from "../src/tools/create-note";
import { createReadNoteTool } from "../src/tools/read-note";
import { createEditNoteTool } from "../src/tools/edit-note";
import { createListFilesTool } from "../src/tools/list-files";

const TEST_VAULT_DIR = path.resolve(__dirname, ".test-vault");
const TEST_VAULT_CONFIG = [{ name: "test-vault", path: TEST_VAULT_DIR }];

describe("E2E: CRUD Operations", () => {
  let server: ObsidianServer;
  let callToolHandler: any; // To store the handler for direct invocation

  beforeEach(async () => {
    // Create the test vault directory
    await fs.mkdir(TEST_VAULT_DIR, { recursive: true });
    // Create the .obsidian directory (essential for vault validation)
    await fs.mkdir(path.join(TEST_VAULT_DIR, ".obsidian"), { recursive: true });

    // Instantiate the server
    server = new ObsidianServer(TEST_VAULT_CONFIG);

    // Register tools
    const vaultsMap = new Map(TEST_VAULT_CONFIG.map(v => [v.name, v.path]));
    server.registerTool(createCreateNoteTool(vaultsMap));
    server.registerTool(createReadNoteTool(vaultsMap));
    server.registerTool(createEditNoteTool(vaultsMap));
    server.registerTool(createListFilesTool(vaultsMap));

    // Expose the CallToolRequest handler for direct calling
    // This assumes the handler is stored/accessible after setupHandlers() is called
    // (Requires inspecting ObsidianServer implementation or potentially modifying it slightly 
    // if the handler isn't easily accessible externally for testing)
    // For now, let's assume we can get it or find a way.
    // Placeholder: Find a way to get the actual handler
    callToolHandler = async (request: any) => {
      // Simulate server request validation (rate limit, etc.) - simplified for now
      // server['validateRequest'](request); // Accessing private method - adjust if needed

      const tool = server['tools'].get(request.params.name);
      if (!tool) throw new Error(`Tool not found: ${request.params.name}`);

      try {
        const validatedArgs = tool.inputSchema.parse(request.params.arguments);
        const vaultPath = vaultsMap.get(validatedArgs.vault);
        if (!vaultPath) throw new Error(`Vault not found: ${validatedArgs.vault}`);

        // Call the tool's actual handler (generated by createTool)
        // It expects only the validated args
        const result = await tool.handler(validatedArgs);
        return result; // Return the raw result
      } catch (error) {
        // Simulate error handling
        console.error("E2E Test: Tool execution error:", error);
        throw error; // Rethrow for test failure
      }
    };
  });

  afterEach(async () => {
    // Clean up the test vault directory
    await fs.rm(TEST_VAULT_DIR, { recursive: true, force: true });
  });

  test("should create, read, edit, and list a note", async () => {
    const noteRelativePath = "test-note.md";
    const noteFullPath = path.join(TEST_VAULT_DIR, noteRelativePath);
    const initialContent = "# Hello World";
    const editedContent = "# Hello Updated World";

    // 1. Create Note
    const createRequest = {
      jsonrpc: "2.0",
      method: "callTool",
      id: "req-1",
      params: {
        name: "create-note",
        arguments: {
          vault: "test-vault",
          path: noteRelativePath,
          content: initialContent
        }
      }
    };
    const createResponse = await callToolHandler(createRequest);
    // Check the MCP content structure
    expect(createResponse.content).toBeInstanceOf(Array);
    expect(createResponse.content[0].type).toBe("text");
    expect(createResponse.content[0].text).toContain("Note created successfully");
    // Verify file exists and has content
    const createdContent = await fs.readFile(noteFullPath, "utf-8");
    expect(createdContent).toBe(initialContent);

    // 2. Read Note
    const readRequest = {
      jsonrpc: "2.0",
      method: "callTool",
      id: "req-2",
      params: {
        name: "read-note",
        arguments: {
          vault: "test-vault",
          path: noteRelativePath
        }
      }
    };
    const readResponse = await callToolHandler(readRequest);
    expect(readResponse.content).toBeInstanceOf(Array);
    expect(readResponse.content[0].type).toBe("text");
    // Read note response now includes the content and the status message
    expect(readResponse.content[0].text).toContain(initialContent);
    expect(readResponse.content[0].text).toContain("Note read successfully");

    // 3. Edit Note
    const editRequest = {
      jsonrpc: "2.0",
      method: "callTool",
      id: "req-3",
      params: {
        name: "edit-note",
        arguments: {
          vault: "test-vault",
          path: noteRelativePath,
          content: editedContent,
          operation: "replace"
        }
      }
    };
    const editResponse = await callToolHandler(editRequest);
    expect(editResponse.content).toBeInstanceOf(Array);
    expect(editResponse.content[0].type).toBe("text");
    // Expect specific message for replace operation
    expect(editResponse.content[0].text).toContain("Note replaced successfully");
    // Verify file content updated
    const updatedContent = await fs.readFile(noteFullPath, "utf-8");
    expect(updatedContent).toBe(editedContent);

  });

  // Add more tests for edge cases, different tools, folders, etc.

}); 